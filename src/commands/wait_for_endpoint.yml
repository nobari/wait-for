---
description: >
  Wait for an HTTP endpoint to become available before proceeding.

parameters:
  url:
    type: string
    description: "The URL to poll (e.g., http://localhost:8080/health)"
  service_name:
    type: string
    description: "A descriptive name for the service you're waiting for"
  timeout:
    type: integer
    default: 120
    description: Maximum time to wait in seconds before failing
  interval:
    type: integer
    default: 5
    description: Interval between checks in seconds
  verbose:
    type: boolean
    default: true
    description: Enable verbose output
  status_code:
    type: integer
    default: 200
    description: Expected HTTP status code to consider endpoint available
  headers:
    type: string
    default: ""
    description: >-
      Optional HTTP headers to include in requests
      (format: 'Header-Name: value')
  method:
    type: enum
    enum: [GET, POST, HEAD]
    default: GET
    description: HTTP method to use
  fail_on_error:
    type: boolean
    default: true
    description: >-
      Whether to fail the build if the endpoint doesn't become available
      within timeout

steps:
  - run:
      name: Wait for << parameters.service_name >> endpoint
      command: |
        start_time=$(date +%s)
        end_time=$((start_time + << parameters.timeout >>))

        # Prepare headers
        HEADER_ARGS=""
        if [ -n "<< parameters.headers >>" ]; then
          # Split on newlines and add as -H args
          IFS=$'\n'
          for header in << parameters.headers >>; do
            HEADER_ARGS="${HEADER_ARGS} -H \"${header}\""
          done
          unset IFS
        fi

        # Verbose output message
        if [ "<< parameters.verbose >>" = "true" ]; then
          echo "Waiting for << parameters.service_name >>"
          echo "URL: << parameters.url >>"
          echo "Timeout: << parameters.timeout >>s,"
          echo "Interval: << parameters.interval >>s,"
          echo "Expected status: << parameters.status_code >>"
          if [ -n "<< parameters.headers >>" ]; then
            echo "Using headers: << parameters.headers >>"
          fi
        fi

        # Main wait loop
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))

          # Check timeout
          if [ $current_time -gt $end_time ]; then
            echo "Timeout after ${elapsed}s"
            echo "Service: << parameters.service_name >>"
            if [ "<< parameters.fail_on_error >>" = "true" ]; then
              exit 1
            else
              echo "Continuing despite endpoint not being available"
              exit 0
            fi
          fi

          # Attempt to connect with appropriate options
          if [ "<< parameters.verbose >>" = "true" ]; then
            echo "Checking service... (${elapsed}s elapsed)"
          fi

          # Build curl command
          CURL_CMD="curl -s -o /dev/null -w \"%{http_code}\" "
          CURL_CMD="${CURL_CMD} -X << parameters.method >>"
          CURL_CMD="${CURL_CMD} ${HEADER_ARGS}"
          CURL_CMD="${CURL_CMD} \"<< parameters.url >>\""

          # Debug information when verbose is true
          if [ "<< parameters.verbose >>" = "true" ]; then
            echo "Debug: Full curl command: ${CURL_CMD}"

            # Capture detailed curl output for debugging
            set +e  # Don't exit on error
            eval ${CURL_CMD} -v > curl_output.txt 2>&1
            curl_exit_code=$?
            set -e  # Exit on error (restore default behavior)

            echo "Debug: curl exit code: ${curl_exit_code}"
            echo "Debug: curl output:"
            cat curl_output.txt
          fi

          # Execute curl command for actual check
          status_code=$(eval ${CURL_CMD} || echo "failed_$?")

          if [ "$status_code" = "<< parameters.status_code >>" ]; then
            echo "<< parameters.service_name >> is up!"
            echo "HTTP << parameters.status_code >> received"
            exit 0
          elif [ "<< parameters.verbose >>" = "true" ]; then
            if [ -n "$status_code" ]; then
              if [[ "$status_code" == failed_* ]]; then
                exit_code=${status_code#failed_}
                echo "Curl command failed with exit code: ${exit_code}"
              else
                echo "Received status code: $status_code"
                echo "(waiting for << parameters.status_code >>)"
              fi
            else
              echo "Connection failed"
            fi
          fi

          sleep << parameters.interval >>
        done
